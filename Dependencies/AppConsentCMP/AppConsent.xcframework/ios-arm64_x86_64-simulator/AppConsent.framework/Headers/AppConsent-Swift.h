#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef APPCONSENT_SWIFT_H
#define APPCONSENT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AppConsent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// Auhtorization Given
typedef SWIFT_ENUM(NSInteger, ACATTAuthorizationGiven, open) {
  ACATTAuthorizationGivenNotGiven = 0,
  ACATTAuthorizationGivenGiven = 1,
  ACATTAuthorizationGivenNotSupported = 2,
};

/// Auhtorization Status
typedef SWIFT_ENUM(NSInteger, ACATTAuthorizationStatus, open) {
  ACATTAuthorizationStatusFailure = 0,
  ACATTAuthorizationStatusSuccess = 1,
  ACATTAuthorizationStatusNotSupported = 2,
};


/// Configuration object from Hello
SWIFT_CLASS("_TtC10AppConsent15ACConfiguration")
@interface ACConfiguration : NSObject
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Consent Class
SWIFT_CLASS("_TtC10AppConsent9ACConsent")
@interface ACConsent : NSObject
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class to display the current identifier
SWIFT_CLASS("_TtC10AppConsent19ACCurrentIdentifier")
@interface ACCurrentIdentifier : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSString;
@protocol AppConsentDelegate;

/// <code>ACNotice</code> is the entry point to interract with our CMP.
/// You first configure an instance of it with your AppKey <code>init(withAppKey:forceApplyGDPR:forceATT:verticalButtons:fullscreen:)</code>
/// To monitor the lifecycle of the notice, consider setting <code>delegate</code> implementing  the <code>AppConsentDelegate</code> protocol.
/// Then use <code>presentNotice(viewController:)</code> to display the CMP UI if needed.
SWIFT_CLASS("_TtC10AppConsent8ACNotice")
@interface ACNotice : NSObject
/// Get AppKey String
@property (nonatomic, readonly, copy) NSString * _Nonnull appKey;
/// Get force apply GDPR Boolean
@property (nonatomic, readonly) BOOL forceApplyGDPR;
/// Get force App Tracking Transparency Boolean
@property (nonatomic, readonly) BOOL forceATT;
/// Display buttons vertically on introduction page if set to true
@property (nonatomic, readonly) BOOL verticalButtons;
/// Display introduction page in fullscreen if set to true
@property (nonatomic, readonly) BOOL fullscreen;
/// Get dedicated endpoint URL String
@property (nonatomic, readonly, copy) NSString * _Nullable dedicatedEndpointURL;
/// Get dedicated assets URL String
@property (nonatomic, readonly, copy) NSString * _Nullable dedicatedAssetsURL;
/// Set the <code>AppConsentDelegate</code> to receive callbacks
@property (nonatomic, strong) id <AppConsentDelegate> _Nullable delegate;
/// Setup the AppConsent CMP.
/// Setup the CMP by calling this function, passing it your <code>appKey</code>.
/// The CMP detects if the app is running on a device that is inside a GDPR country, with <code>forceApplyGDPR</code> you can choose to bypass the check, and let the CMP always behave according to GDPR.
/// The ATT checks can be enforced with <code>forceATT</code>, this defaults to <code>false</code>.
/// \param appKey The AppKey String from Back Office.
///
/// \param forceApplyGDPR Boolean to indicate if you want to force GDPR
///
/// \param forceATT Boolean to indicate if you want to force App Tracking Transparency, defaults to false
///
/// \param verticalButtons Display buttons vertically on introduction page if set to true, defaults to false
///
/// \param fullscreen Display introduction page in fullscreen if set to true, defaults to false
///
/// \param dedicatedEndpointURL Set a custom URL to your dedicated AppConsent endpoint, leave it nil for default
///
/// \param dedicatedAssetURL Set a custom URL to your dedicated endpoint for illustrated mode assets, leave it nil for default, asset images should be placed at root of endpoint and be named illustration-header.jpg, illustration-footer.jpg, and illustration-success.jpg
///
- (nonnull instancetype)initWithAppKey:(NSString * _Nonnull)appKey forceApplyGDPR:(BOOL)forceApplyGDPR forceATT:(BOOL)forceATT verticalButtons:(BOOL)verticalButtons fullscreen:(BOOL)fullscreen dedicatedEndpointURL:(NSString * _Nullable)dedicatedEndpointURL dedicatedAssetsURL:(NSString * _Nullable)dedicatedAssetsURL OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class ACShipData;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Asynchronous method to send ACShipData Struct in our server.
/// \param data ACShipData object
///
/// \param success Everything is ok
///
/// \param failure Error occured
///
- (void)setExternalDataWithShipData:(ACShipData * _Nonnull)shipData success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end

@class ACState;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Retrieve external ids from UserPreferences.
/// This only returns the external ids present in the UserPreferences local storage, without checking them out from the backend, external ids are only synchronized after a call to <code>presentNotice(viewController:)</code>, <code>presentSettings(viewController:)</code> or <code>checkForUpdate(_:failure:)</code>.
///
/// returns:
/// All external Ids stored in UserPreferences
- (NSDictionary<NSString *, NSString *> * _Nonnull)getExternalIds SWIFT_WARN_UNUSED_RESULT;
/// Store a set of external id allong the consent.
/// The ids are synchornised with the consents upon calling <code>presentNotice(viewController:)</code>, <code>presentSettings(viewController:)</code> or <code>checkForUpdate(_:failure:)</code>, so this should be called before calling presentNotice(), presentSettings() or checkForUpdate().
/// This overrides previously set External Ids in the local storage, but the change won’t be synchronized with our backend untill a call to presentNotice(), presentSettings(), or checkForUpdate() is made.
/// \param externalIds String dictionary.
///
- (nonnull instancetype)setExternalIdsWithExternalIds:(NSDictionary<NSString *, NSString *> * _Nonnull)externalIds;
/// Send the external ids you have stored with <code>setExternalIds(externalIds:)</code> to the server.
/// The external ids are also saved automatically when calling <code>presentNotice(viewController:)</code>, or <code>presentSettings(viewController:)</code>, whether or not the notice is presented, or when calling <code>checkForUpdate(_:failure:)</code>.
/// Saving External Ids with this method doesn’t work unless there has been a previous consent registered with presentNotice(), or presentSettings(), so in most cases it is preferable to simply rely on presentNotice(), presentSettings(), or checkForUpdate() to save the External Ids.
/// \param success <code>ACState</code> and <code>ACConfiguration</code> class.
///
/// \param failure Error occured
///
- (void)saveExternalIdsWithSuccess:(void (^ _Nullable)(ACState * _Nullable, ACConfiguration * _Nullable))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Returns SFBX copyright information with Frameworks version number
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull SFBXCopyright;)
+ (NSString * _Nonnull)SFBXCopyright SWIFT_WARN_UNUSED_RESULT;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Set all consentable values that you want in one method.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>value</code> as an <code>ACConsentableType</code> instead of NSInteger.
/// \param values <code>Key</code> is an iabObjectId, <code>Value</code> is an NSInteger (<code>0</code>: <code>pending</code> ,<code>1</code>: <code>allowed</code> , <code>-1</code>: <code>denied</code> ,<code>-2</code>: <code>undefined</code>)
///
/// \param success Callback if everything is ok
///
/// \param failure There is an error
///
- (void)setConsentableConsentsWithValues:(NSDictionary<NSString *, NSNumber *> * _Nonnull)values success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Set all consentable values that you want in one method.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>values</code> as an <code>ACConsentableType</code> instead of NSInteger.
/// \param values <code>Key</code> is an extraId, <code>Value</code> is an NSInteger (<code>0</code>: <code>pending</code> ,<code>1</code>: <code>allowed</code> , <code>-1</code>: <code>denied</code> ,<code>-2</code>: <code>undefined</code>)
///
/// \param success Callback if everything is ok
///
/// \param failure There is an error
///
- (void)setExtraConsentableConsentsWithValues:(NSDictionary<NSString *, NSNumber *> * _Nonnull)values success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Check if current device supports App Tracking Transparency framework.
///
/// returns:
/// Boolean
- (BOOL)appTrackingIsAvailable SWIFT_WARN_UNUSED_RESULT;
/// Method to know if App Tracking Transparency is alreayd given or not.
///
/// returns:
/// ACATTAuthorizationGiven enum
- (enum ACATTAuthorizationGiven)appTrackingAuthorizationGiven SWIFT_WARN_UNUSED_RESULT;
/// Get the App Tracking Auhtorization Status
///
/// returns:
/// ACATTAuthorizationStatus enum
- (enum ACATTAuthorizationStatus)appTrackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
/// Request the authorization for App Tracking Transparency
/// \param completion ACATTAuthorizationStatus enum
///
- (void)appTrackingRequestAuthorization:(void (^ _Nullable)(enum ACATTAuthorizationStatus))completion;
/// Display ATT for existing users who have already given their consent.
/// Display only if ATT is supported, and if purpose 1 is <code>true</code>.
/// \param completion Success callback if needed with user authorization status
///
- (void)displayATTIfNeeded:(void (^ _Nullable)(enum ACATTAuthorizationStatus))completion;
/// Method to know if a floating purpose is allowed or not.
/// \param extraId The extraId of your floating purpose
///
///
/// returns:
/// Boolean
- (BOOL)floatingPurposeAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Asynchronous method to save the App Tracking Transparency floating purpose.
/// \param value Boolean
///
/// \param success Everything is ok
///
/// \param failure An Error occured
///
- (void)saveATTFloatingPurposeWith:(BOOL)value success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end

@class UIViewController;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Displays the CMP Notice if needed.
/// Once the CMP has been initialized, call this to display the Notice UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, then the CMP Notice is not displayed.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed, so the user can save their preferences.
///   </li>
/// </ul>
/// The <code>force</code> option tells the Notice to always display the preferences screen, even if the user has already saved their preferences. The default behavior is <code>false</code>.
/// If set to <code>true</code>, then the behavior changes has such:
/// <ul>
///   <li>
///     if user has already saved their preferences before, the introduction and global choices screen is not shown, and the CMP Notice displays the detailed preferences page. This is used to allow the user to change their preferences.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed as usual.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// \param force Boolean to force displaying notice, see discussion.
///
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP was displayed, <code>false</code> otherwise.
- (BOOL)presentNoticeWithForce:(BOOL)force viewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using presentNotice(viewController:) or presentSettings(viewController:) ");
/// Closure to know when a consent is given
/// \param success Everytthing is ok
///
/// \param failure Error occured
///
- (void)consentGivenSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using an ``AppConsentDelegate`` ");
/// Closure to know when a geolocation consent is given
/// \param success Everytthing is ok
///
/// \param failure Error occured
///
- (void)geolocationConsentGivenSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using an ``AppConsentDelegate`` ");
- (BOOL)consentableAllowedWithIabId:(NSString * _Nonnull)iabId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("iabId has been changed to an UInt32. Prefer using this function passing also a type.", "consentableAllowed(iabId:type:)");
- (BOOL)consentableAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "extraConsentableAllowedWithExtraId:");
- (BOOL)vendorAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "extraVendorAllowedWithExtraId:");
/// Get a boolean to know if device is running in a GDPR Countries.
///
/// returns:
/// <code>true</code> if current device is located in a country subject to GDPR
- (BOOL)isGDPRCountry SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete, and will be removed in a future version");
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Get a boolean to know if a consentable is allowed or not.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>type</code> as an <code>ACConsentableType</code>.
/// \param iabId Is an iabId String
///
/// \param type is an NSInteger (<code>0</code>: <code>purpose</code> ,<code>1</code>: <code>feature</code> , <code>2</code>: <code>specialFeature</code> ,<code>3</code>: <code>specialPurpose</code>)
///
///
/// returns:
/// <code>true</code> if consentable is allowed.
- (BOOL)consentableAllowedWithIabId:(uint32_t)iabId type:(NSInteger)type SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a consentable is allowed or not.
/// \param objectId Is an objectId String
///
///
/// returns:
/// Boolean
- (BOOL)consentableAllowedWithObjectId:(uint32_t)objectId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if an extra consentable is allowed or not.
/// \param extraId Is an extraId String
///
///
/// returns:
/// Boolean
- (BOOL)extraConsentableAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a vendor is allowed or not.
/// \param iabId Is an iabId String
///
///
/// returns:
/// Boolean
- (BOOL)vendorAllowedWithIabId:(uint32_t)iabId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if an extra vendor is allowed or not.
/// \param extraId Is an extraId String
///
///
/// returns:
/// Boolean
- (BOOL)extraVendorAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a stack is allowed or not.
/// \param iabId Is an iabId UInt32
///
///
/// returns:
/// Boolean
- (BOOL)stackAllowedWithIabId:(uint32_t)iabId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all consentables are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allConsentablesAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all consentables are disallowed or not.
///
/// returns:
/// Boolean
- (BOOL)allConsentablesDisallowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all stacks are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allStacksAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all vendors are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allVendorsAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if current user accept all consentables, stacks and vendors or not.
///
/// returns:
/// Boolean
- (BOOL)userAcceptAll SWIFT_WARN_UNUSED_RESULT;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Displays the CMP Notice if needed.
/// Once the CMP has been initialized, call this to display the Notice UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, then the CMP Notice is not displayed.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed, so the user can save their preferences.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP will be displayed, <code>false</code> otherwise.
- (BOOL)presentNoticeWithViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
/// Displays the CMP Settings.
/// Once the CMP has been initialized, call this to display the Privacy Settings UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, the introduction and global choices screen is not shown, and the CMP Notice displays the detailed Settings page. This is used to allow the user to change their preferences.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed as usual, including the introduction screen.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP was displayed, <code>false</code> otherwise.
- (BOOL)presentSettingsWithViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
/// Display the geolocation notice.
/// This function returns as soon as the CMP Geolocation Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The current UIViewController you want to display
///
- (void)presentGeolocation:(UIViewController * _Nonnull)viewController;
/// Clears user consents preferences.
/// This only clears local consent in UserDefaults, all of the IABTCF UserDefaults are erased.
- (void)clearConsent;
/// This functions checks if user consent preferences have already been saved to userDefault.
/// Internally, it only checks that a value is present in userDefaults for the key <code>IABConstants.TC_STRING</code>.
/// This function performs no other checks nor validation.
///
/// returns:
/// true if a consent was given
- (BOOL)consentGiven SWIFT_WARN_UNUSED_RESULT;
/// Asynchronous method to check if an update is needed from backend.
/// \param success Boolean to know if update is needed or not.
///
/// \param failure Error occured
///
- (void)checkForUpdate:(void (^ _Nullable)(BOOL))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// It’s a method to open App Settings directly.
- (void)openAppSettings;
@end


SWIFT_CLASS("_TtC10AppConsent10ACShipData")
@interface ACShipData : NSObject
@property (nonatomic, copy) NSString * _Nullable age;
@property (nonatomic, copy) NSString * _Nullable appNameBundle;
@property (nonatomic, copy) NSString * _Nullable consentString;
@property (nonatomic, copy) NSString * _Nullable csp;
@property (nonatomic, copy) NSString * _Nullable dateOfBirth;
@property (nonatomic, copy) NSString * _Nullable deviceCountryCode;
@property (nonatomic, copy) NSString * _Nullable deviceManufacturer;
@property (nonatomic, copy) NSString * _Nullable deviceOS;
@property (nonatomic, copy) NSString * _Nullable country;
@property (nonatomic, copy) NSString * _Nullable floor;
@property (nonatomic, copy) NSString * _Nullable postCode;
@property (nonatomic, copy) NSString * _Nullable deviceCarrier;
@property (nonatomic, copy) NSString * _Nullable deviceModel;
@property (nonatomic, copy) NSString * _Nullable deviceOSVersion;
@property (nonatomic, copy) NSString * _Nullable email;
@property (nonatomic, copy) NSString * _Nullable externalId;
@property (nonatomic, copy) NSString * _Nullable firstName;
@property (nonatomic, copy) NSString * _Nullable gender;
@property (nonatomic, copy) NSString * _Nullable household;
@property (nonatomic, copy) NSString * _Nullable ipv4Address;
@property (nonatomic, copy) NSString * _Nullable ipv6Address;
@property (nonatomic, copy) NSString * _Nullable lastName;
@property (nonatomic, copy) NSString * _Nullable macAddress;
@property (nonatomic, copy) NSString * _Nullable maid;
@property (nonatomic, copy) NSString * _Nullable maidType;
@property (nonatomic, copy) NSString * _Nullable networkType;
@property (nonatomic, copy) NSString * _Nullable phone;
@property (nonatomic, copy) NSString * _Nullable region;
@property (nonatomic, copy) NSString * _Nullable revenues;
@property (nonatomic, copy) NSString * _Nullable signalStrength;
@property (nonatomic, copy) NSString * _Nullable streetName;
@property (nonatomic, copy) NSString * _Nullable streetNo;
@property (nonatomic, copy) NSString * _Nullable streetType;
@property (nonatomic, copy) NSString * _Nullable timestampCollect;
@property (nonatomic, copy) NSString * _Nullable town;
@property (nonatomic, copy) NSString * _Nullable unstructuredData;
@property (nonatomic, copy) NSString * _Nullable wifiSSID;
- (nonnull instancetype)initWithAge:(NSString * _Nullable)age appNameBundle:(NSString * _Nullable)appNameBundle consentString:(NSString * _Nullable)consentString csp:(NSString * _Nullable)csp dateOfBirth:(NSString * _Nullable)dateOfBirth deviceCountryCode:(NSString * _Nullable)deviceCountryCode deviceManufacturer:(NSString * _Nullable)deviceManufacturer deviceOS:(NSString * _Nullable)deviceOS country:(NSString * _Nullable)country floor:(NSString * _Nullable)floor postCode:(NSString * _Nullable)postCode deviceCarrier:(NSString * _Nullable)deviceCarrier deviceModel:(NSString * _Nullable)deviceModel deviceOSVersion:(NSString * _Nullable)deviceOSVersion email:(NSString * _Nullable)email externalId:(NSString * _Nullable)externalId firstName:(NSString * _Nullable)firstName gender:(NSString * _Nullable)gender household:(NSString * _Nullable)household ipv4Address:(NSString * _Nullable)ipv4Address ipv6Address:(NSString * _Nullable)ipv6Address lastName:(NSString * _Nullable)lastName macAddress:(NSString * _Nullable)macAddress maid:(NSString * _Nullable)maid maidType:(NSString * _Nullable)maidType networkType:(NSString * _Nullable)networkType phone:(NSString * _Nullable)phone region:(NSString * _Nullable)region revenues:(NSString * _Nullable)revenues signalStrength:(NSString * _Nullable)signalStrength streetName:(NSString * _Nullable)streetName streetNo:(NSString * _Nullable)streetNo streetType:(NSString * _Nullable)streetType timestampCollect:(NSString * _Nullable)timestampCollect town:(NSString * _Nullable)town unstructuredData:(NSString * _Nullable)unstructuredData wifiSSID:(NSString * _Nullable)wifiSSID OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The State object of the app
SWIFT_CLASS("_TtC10AppConsent7ACState")
@interface ACState : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end








/// The AppConsentDelegate protocol allows you to follow the notice lifecycle.
/// You can register as the notice delegate when initializing it through the <code>ACNotice</code> class.
/// \code
/// let appconsent = ACNotice(withAppKey: "YOUR_APP_KEY", forceApplyGDPR: true, forceATT: true)
/// appconsent.delegate = self
///
/// \endcode
SWIFT_PROTOCOL("_TtP10AppConsent18AppConsentDelegate_")
@protocol AppConsentDelegate
/// Called when the notice has been completed by the user or closed
- (void)appConsentDidFinish;
/// Called if anything went wrong in the notice lifecycle
/// \param error error describing the issue
///
- (void)appConsentDidFail:(NSError * _Nullable)error;
@optional
/// Called when a geolocation banner or notice has received an answer by the user.
- (void)appConsentGeolocationDidFinish;
/// Called when an error occur while trying to collect consent for geolocation purposes.
/// \param error error describing the issue
///
- (void)appConsentGeolocationDidFail:(NSError * _Nullable)error;
/// Optional, called when the notice introduction will be presented
- (void)appConsentWillAppear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction has been presented
- (void)appConsentDidAppear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction will close
- (void)appConsentWillDisappear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction has been closed
- (void)appConsentDidDisappear SWIFT_DEPRECATED_MSG("This is now obsolete.");
@end


/// Extension of the <code>AppConsentDelegate</code> protocol dedicated to the consents of purposes using the user’s geolocation.
SWIFT_PROTOCOL("_TtP10AppConsent36AppConsentGeolocationConsentDelegate_") SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate`` ")
@protocol AppConsentGeolocationConsentDelegate <AppConsentDelegate>
/// Called when a geolocation banner or notice has received an answer by the user.
- (void)appConsentGeolocationConsentReceived SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate.appConsentGeolocationDidFinish()`` ");
/// Called when an error occur while trying to collect consent for geolocation purposes.
/// \param error The reason of the error.
///
- (void)appConsentGeolocationConsentFailed:(NSError * _Nonnull)error SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate.appConsentGeolocationDidFail(_ error: Error)`` ");
@optional
/// Should the geolocation notice enlarge the geolocation icon?
///
/// returns:
/// <code>true</code> to display a bigger size image.
- (BOOL)displayBigGeolocationImage SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Should the buttons be in the scroll view of the geolocation notice.
/// important:
/// Only applies if the list of geoloc purposes is more than one.
///
/// returns:
/// <code>true</code> if the buttons should scroll, <code>false</code> otherwise.
- (BOOL)geolocationCtaScrolling SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete.");
@end































#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef APPCONSENT_SWIFT_H
#define APPCONSENT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AppConsent",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
/// Auhtorization Given
typedef SWIFT_ENUM(NSInteger, ACATTAuthorizationGiven, open) {
  ACATTAuthorizationGivenNotGiven = 0,
  ACATTAuthorizationGivenGiven = 1,
  ACATTAuthorizationGivenNotSupported = 2,
};

/// Auhtorization Status
typedef SWIFT_ENUM(NSInteger, ACATTAuthorizationStatus, open) {
  ACATTAuthorizationStatusFailure = 0,
  ACATTAuthorizationStatusSuccess = 1,
  ACATTAuthorizationStatusNotSupported = 2,
};


/// Configuration object from Hello
SWIFT_CLASS("_TtC10AppConsent15ACConfiguration")
@interface ACConfiguration : NSObject
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Consent Class
SWIFT_CLASS("_TtC10AppConsent9ACConsent")
@interface ACConsent : NSObject
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class to display the current identifier
SWIFT_CLASS("_TtC10AppConsent19ACCurrentIdentifier")
@interface ACCurrentIdentifier : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSString;
@protocol AppConsentDelegate;

/// <code>ACNotice</code> is the entry point to interract with our CMP.
/// You first configure an instance of it with your AppKey <code>init(withAppKey:forceApplyGDPR:forceATT:verticalButtons:fullscreen:)</code>
/// To monitor the lifecycle of the notice, consider setting <code>delegate</code> implementing  the <code>AppConsentDelegate</code> protocol.
/// Then use <code>presentNotice(viewController:)</code> to display the CMP UI if needed.
SWIFT_CLASS("_TtC10AppConsent8ACNotice")
@interface ACNotice : NSObject
/// Get AppKey String
@property (nonatomic, readonly, copy) NSString * _Nonnull appKey;
/// Get force apply GDPR Boolean
@property (nonatomic, readonly) BOOL forceApplyGDPR;
/// Get force App Tracking Transparency Boolean
@property (nonatomic, readonly) BOOL forceATT;
/// Display buttons vertically on introduction page if set to true
@property (nonatomic, readonly) BOOL verticalButtons;
/// Display introduction page in fullscreen if set to true
@property (nonatomic, readonly) BOOL fullscreen;
/// Get dedicated endpoint URL String
@property (nonatomic, readonly, copy) NSString * _Nullable dedicatedEndpointURL;
/// Get dedicated assets URL String
@property (nonatomic, readonly, copy) NSString * _Nullable dedicatedAssetsURL;
/// Set the <code>AppConsentDelegate</code> to receive callbacks
@property (nonatomic, strong) id <AppConsentDelegate> _Nullable delegate;
/// Setup the AppConsent CMP.
/// Setup the CMP by calling this function, passing it your <code>appKey</code>.
/// The CMP detects if the app is running on a device that is inside a GDPR country, with <code>forceApplyGDPR</code> you can choose to bypass the check, and let the CMP always behave according to GDPR.
/// The ATT checks can be enforced with <code>forceATT</code>, this defaults to <code>false</code>.
/// \param appKey The AppKey String from Back Office.
///
/// \param forceApplyGDPR Boolean to indicate if you want to force GDPR
///
/// \param forceATT Boolean to indicate if you want to force App Tracking Transparency, defaults to false
///
/// \param verticalButtons Display buttons vertically on introduction page if set to true, defaults to false
///
/// \param fullscreen Display introduction page in fullscreen if set to true, defaults to false
///
/// \param dedicatedEndpointURL Set a custom URL to your dedicated AppConsent endpoint, leave it nil for default
///
/// \param dedicatedAssetURL Set a custom URL to your dedicated endpoint for illustrated mode assets, leave it nil for default, asset images should be placed at root of endpoint and be named illustration-header.jpg, illustration-footer.jpg, and illustration-success.jpg
///
- (nonnull instancetype)initWithAppKey:(NSString * _Nonnull)appKey forceApplyGDPR:(BOOL)forceApplyGDPR forceATT:(BOOL)forceATT verticalButtons:(BOOL)verticalButtons fullscreen:(BOOL)fullscreen dedicatedEndpointURL:(NSString * _Nullable)dedicatedEndpointURL dedicatedAssetsURL:(NSString * _Nullable)dedicatedAssetsURL OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class ACShipData;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Asynchronous method to send ACShipData Struct in our server.
/// \param data ACShipData object
///
/// \param success Everything is ok
///
/// \param failure Error occured
///
- (void)setExternalDataWithShipData:(ACShipData * _Nonnull)shipData success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end

@class ACState;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Retrieve external ids from UserPreferences.
/// This only returns the external ids present in the UserPreferences local storage, without checking them out from the backend, external ids are only synchronized after a call to <code>presentNotice(viewController:)</code>, <code>presentSettings(viewController:)</code> or <code>checkForUpdate(_:failure:)</code>.
///
/// returns:
/// All external Ids stored in UserPreferences
- (NSDictionary<NSString *, NSString *> * _Nonnull)getExternalIds SWIFT_WARN_UNUSED_RESULT;
/// Store a set of external id allong the consent.
/// The ids are synchornised with the consents upon calling <code>presentNotice(viewController:)</code>, <code>presentSettings(viewController:)</code> or <code>checkForUpdate(_:failure:)</code>, so this should be called before calling presentNotice(), presentSettings() or checkForUpdate().
/// This overrides previously set External Ids in the local storage, but the change won’t be synchronized with our backend untill a call to presentNotice(), presentSettings(), or checkForUpdate() is made.
/// \param externalIds String dictionary.
///
- (nonnull instancetype)setExternalIdsWithExternalIds:(NSDictionary<NSString *, NSString *> * _Nonnull)externalIds;
/// Send the external ids you have stored with <code>setExternalIds(externalIds:)</code> to the server.
/// The external ids are also saved automatically when calling <code>presentNotice(viewController:)</code>, or <code>presentSettings(viewController:)</code>, whether or not the notice is presented, or when calling <code>checkForUpdate(_:failure:)</code>.
/// Saving External Ids with this method doesn’t work unless there has been a previous consent registered with presentNotice(), or presentSettings(), so in most cases it is preferable to simply rely on presentNotice(), presentSettings(), or checkForUpdate() to save the External Ids.
/// \param success <code>ACState</code> and <code>ACConfiguration</code> class.
///
/// \param failure Error occured
///
- (void)saveExternalIdsWithSuccess:(void (^ _Nullable)(ACState * _Nullable, ACConfiguration * _Nullable))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Returns SFBX copyright information with Frameworks version number
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull SFBXCopyright;)
+ (NSString * _Nonnull)SFBXCopyright SWIFT_WARN_UNUSED_RESULT;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Set all consentable values that you want in one method.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>value</code> as an <code>ACConsentableType</code> instead of NSInteger.
/// \param values <code>Key</code> is an iabObjectId, <code>Value</code> is an NSInteger (<code>0</code>: <code>pending</code> ,<code>1</code>: <code>allowed</code> , <code>-1</code>: <code>denied</code> ,<code>-2</code>: <code>undefined</code>)
///
/// \param success Callback if everything is ok
///
/// \param failure There is an error
///
- (void)setConsentableConsentsWithValues:(NSDictionary<NSString *, NSNumber *> * _Nonnull)values success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Set all consentable values that you want in one method.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>values</code> as an <code>ACConsentableType</code> instead of NSInteger.
/// \param values <code>Key</code> is an extraId, <code>Value</code> is an NSInteger (<code>0</code>: <code>pending</code> ,<code>1</code>: <code>allowed</code> , <code>-1</code>: <code>denied</code> ,<code>-2</code>: <code>undefined</code>)
///
/// \param success Callback if everything is ok
///
/// \param failure There is an error
///
- (void)setExtraConsentableConsentsWithValues:(NSDictionary<NSString *, NSNumber *> * _Nonnull)values success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// Check if current device supports App Tracking Transparency framework.
///
/// returns:
/// Boolean
- (BOOL)appTrackingIsAvailable SWIFT_WARN_UNUSED_RESULT;
/// Method to know if App Tracking Transparency is alreayd given or not.
///
/// returns:
/// ACATTAuthorizationGiven enum
- (enum ACATTAuthorizationGiven)appTrackingAuthorizationGiven SWIFT_WARN_UNUSED_RESULT;
/// Get the App Tracking Auhtorization Status
///
/// returns:
/// ACATTAuthorizationStatus enum
- (enum ACATTAuthorizationStatus)appTrackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
/// Request the authorization for App Tracking Transparency
/// \param completion ACATTAuthorizationStatus enum
///
- (void)appTrackingRequestAuthorization:(void (^ _Nullable)(enum ACATTAuthorizationStatus))completion;
/// Display ATT for existing users who have already given their consent.
/// Display only if ATT is supported, and if purpose 1 is <code>true</code>.
/// \param completion Success callback if needed with user authorization status
///
- (void)displayATTIfNeeded:(void (^ _Nullable)(enum ACATTAuthorizationStatus))completion;
/// Method to know if a floating purpose is allowed or not.
/// \param extraId The extraId of your floating purpose
///
///
/// returns:
/// Boolean
- (BOOL)floatingPurposeAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Asynchronous method to save the App Tracking Transparency floating purpose.
/// \param value Boolean
///
/// \param success Everything is ok
///
/// \param failure An Error occured
///
- (void)saveATTFloatingPurposeWith:(BOOL)value success:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
@end

@class UIViewController;

@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Displays the CMP Notice if needed.
/// Once the CMP has been initialized, call this to display the Notice UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, then the CMP Notice is not displayed.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed, so the user can save their preferences.
///   </li>
/// </ul>
/// The <code>force</code> option tells the Notice to always display the preferences screen, even if the user has already saved their preferences. The default behavior is <code>false</code>.
/// If set to <code>true</code>, then the behavior changes has such:
/// <ul>
///   <li>
///     if user has already saved their preferences before, the introduction and global choices screen is not shown, and the CMP Notice displays the detailed preferences page. This is used to allow the user to change their preferences.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed as usual.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// \param force Boolean to force displaying notice, see discussion.
///
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP was displayed, <code>false</code> otherwise.
- (BOOL)presentNoticeWithForce:(BOOL)force viewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using presentNotice(viewController:) or presentSettings(viewController:) ");
/// Closure to know when a consent is given
/// \param success Everytthing is ok
///
/// \param failure Error occured
///
- (void)consentGivenSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using an ``AppConsentDelegate`` ");
/// Closure to know when a geolocation consent is given
/// \param success Everytthing is ok
///
/// \param failure Error occured
///
- (void)geolocationConsentGivenSuccess:(void (^ _Nullable)(void))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using an ``AppConsentDelegate`` ");
- (BOOL)consentableAllowedWithIabId:(NSString * _Nonnull)iabId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("iabId has been changed to an UInt32. Prefer using this function passing also a type.", "consentableAllowed(iabId:type:)");
- (BOOL)consentableAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "extraConsentableAllowedWithExtraId:");
- (BOOL)vendorAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("", "extraVendorAllowedWithExtraId:");
/// Get a boolean to know if device is running in a GDPR Countries.
///
/// returns:
/// <code>true</code> if current device is located in a country subject to GDPR
- (BOOL)isGDPRCountry SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete, and will be removed in a future version");
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Get a boolean to know if a consentable is allowed or not.
/// This is for Objective-C compatibility, on Swift, prefer passing the <code>type</code> as an <code>ACConsentableType</code>.
/// \param iabId Is an iabId String
///
/// \param type is an NSInteger (<code>0</code>: <code>purpose</code> ,<code>1</code>: <code>feature</code> , <code>2</code>: <code>specialFeature</code> ,<code>3</code>: <code>specialPurpose</code>)
///
///
/// returns:
/// <code>true</code> if consentable is allowed.
- (BOOL)consentableAllowedWithIabId:(uint32_t)iabId type:(NSInteger)type SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a consentable is allowed or not.
/// \param objectId Is an objectId String
///
///
/// returns:
/// Boolean
- (BOOL)consentableAllowedWithObjectId:(uint32_t)objectId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if an extra consentable is allowed or not.
/// \param extraId Is an extraId String
///
///
/// returns:
/// Boolean
- (BOOL)extraConsentableAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a vendor is allowed or not.
/// \param iabId Is an iabId String
///
///
/// returns:
/// Boolean
- (BOOL)vendorAllowedWithIabId:(uint32_t)iabId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if an extra vendor is allowed or not.
/// \param extraId Is an extraId String
///
///
/// returns:
/// Boolean
- (BOOL)extraVendorAllowedWithExtraId:(NSString * _Nonnull)extraId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if a stack is allowed or not.
/// \param iabId Is an iabId UInt32
///
///
/// returns:
/// Boolean
- (BOOL)stackAllowedWithIabId:(uint32_t)iabId SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all consentables are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allConsentablesAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all consentables are disallowed or not.
///
/// returns:
/// Boolean
- (BOOL)allConsentablesDisallowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all stacks are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allStacksAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if all vendors are allowed or not.
///
/// returns:
/// Boolean
- (BOOL)allVendorsAllowed SWIFT_WARN_UNUSED_RESULT;
/// Get a boolean to know if current user accept all consentables, stacks and vendors or not.
///
/// returns:
/// Boolean
- (BOOL)userAcceptAll SWIFT_WARN_UNUSED_RESULT;
@end


@interface ACNotice (SWIFT_EXTENSION(AppConsent))
/// Displays the CMP Notice if needed.
/// Once the CMP has been initialized, call this to display the Notice UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, then the CMP Notice is not displayed.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed, so the user can save their preferences.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP will be displayed, <code>false</code> otherwise.
- (BOOL)presentNoticeWithViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
/// Displays the CMP Settings.
/// Once the CMP has been initialized, call this to display the Privacy Settings UI.
/// Internally, this function checks if a user has already saved their preferences:
/// <ul>
///   <li>
///     if yes, the introduction and global choices screen is not shown, and the CMP Notice displays the detailed Settings page. This is used to allow the user to change their preferences.
///   </li>
///   <li>
///     if not, the CMP Notice is displayed as usual, including the introduction screen.
///   </li>
/// </ul>
/// This function returns as soon as the CMP Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The UIViewController on which the AppConsentUI will be attached.
///
///
/// returns:
/// <code>true</code> if the CMP was displayed, <code>false</code> otherwise.
- (BOOL)presentSettingsWithViewController:(UIViewController * _Nonnull)viewController SWIFT_WARN_UNUSED_RESULT;
/// Display the geolocation notice.
/// This function returns as soon as the CMP Geolocation Notice has been displayed, so when it returns, the user may not have saved their preferences yet.
/// To monitor the lifecycle of the presented notice, and get a callback when the notice finishes, consider implementing <code>AppConsentDelegate</code>.
/// \param viewController The current UIViewController you want to display
///
- (void)presentGeolocation:(UIViewController * _Nonnull)viewController;
/// Clears user consents preferences.
/// This only clears local consent in UserDefaults, all of the IABTCF UserDefaults are erased.
- (void)clearConsent;
/// This functions checks if user consent preferences have already been saved to userDefault.
/// Internally, it only checks that a value is present in userDefaults for the key <code>IABConstants.TC_STRING</code>.
/// This function performs no other checks nor validation.
///
/// returns:
/// true if a consent was given
- (BOOL)consentGiven SWIFT_WARN_UNUSED_RESULT;
/// Asynchronous method to check if an update is needed from backend.
/// \param success Boolean to know if update is needed or not.
///
/// \param failure Error occured
///
- (void)checkForUpdate:(void (^ _Nullable)(BOOL))success failure:(void (^ _Nullable)(NSError * _Nonnull))failure;
/// It’s a method to open App Settings directly.
- (void)openAppSettings;
@end


SWIFT_CLASS("_TtC10AppConsent10ACShipData")
@interface ACShipData : NSObject
@property (nonatomic, copy) NSString * _Nullable age;
@property (nonatomic, copy) NSString * _Nullable appNameBundle;
@property (nonatomic, copy) NSString * _Nullable consentString;
@property (nonatomic, copy) NSString * _Nullable csp;
@property (nonatomic, copy) NSString * _Nullable dateOfBirth;
@property (nonatomic, copy) NSString * _Nullable deviceCountryCode;
@property (nonatomic, copy) NSString * _Nullable deviceManufacturer;
@property (nonatomic, copy) NSString * _Nullable deviceOS;
@property (nonatomic, copy) NSString * _Nullable country;
@property (nonatomic, copy) NSString * _Nullable floor;
@property (nonatomic, copy) NSString * _Nullable postCode;
@property (nonatomic, copy) NSString * _Nullable deviceCarrier;
@property (nonatomic, copy) NSString * _Nullable deviceModel;
@property (nonatomic, copy) NSString * _Nullable deviceOSVersion;
@property (nonatomic, copy) NSString * _Nullable email;
@property (nonatomic, copy) NSString * _Nullable externalId;
@property (nonatomic, copy) NSString * _Nullable firstName;
@property (nonatomic, copy) NSString * _Nullable gender;
@property (nonatomic, copy) NSString * _Nullable household;
@property (nonatomic, copy) NSString * _Nullable ipv4Address;
@property (nonatomic, copy) NSString * _Nullable ipv6Address;
@property (nonatomic, copy) NSString * _Nullable lastName;
@property (nonatomic, copy) NSString * _Nullable macAddress;
@property (nonatomic, copy) NSString * _Nullable maid;
@property (nonatomic, copy) NSString * _Nullable maidType;
@property (nonatomic, copy) NSString * _Nullable networkType;
@property (nonatomic, copy) NSString * _Nullable phone;
@property (nonatomic, copy) NSString * _Nullable region;
@property (nonatomic, copy) NSString * _Nullable revenues;
@property (nonatomic, copy) NSString * _Nullable signalStrength;
@property (nonatomic, copy) NSString * _Nullable streetName;
@property (nonatomic, copy) NSString * _Nullable streetNo;
@property (nonatomic, copy) NSString * _Nullable streetType;
@property (nonatomic, copy) NSString * _Nullable timestampCollect;
@property (nonatomic, copy) NSString * _Nullable town;
@property (nonatomic, copy) NSString * _Nullable unstructuredData;
@property (nonatomic, copy) NSString * _Nullable wifiSSID;
- (nonnull instancetype)initWithAge:(NSString * _Nullable)age appNameBundle:(NSString * _Nullable)appNameBundle consentString:(NSString * _Nullable)consentString csp:(NSString * _Nullable)csp dateOfBirth:(NSString * _Nullable)dateOfBirth deviceCountryCode:(NSString * _Nullable)deviceCountryCode deviceManufacturer:(NSString * _Nullable)deviceManufacturer deviceOS:(NSString * _Nullable)deviceOS country:(NSString * _Nullable)country floor:(NSString * _Nullable)floor postCode:(NSString * _Nullable)postCode deviceCarrier:(NSString * _Nullable)deviceCarrier deviceModel:(NSString * _Nullable)deviceModel deviceOSVersion:(NSString * _Nullable)deviceOSVersion email:(NSString * _Nullable)email externalId:(NSString * _Nullable)externalId firstName:(NSString * _Nullable)firstName gender:(NSString * _Nullable)gender household:(NSString * _Nullable)household ipv4Address:(NSString * _Nullable)ipv4Address ipv6Address:(NSString * _Nullable)ipv6Address lastName:(NSString * _Nullable)lastName macAddress:(NSString * _Nullable)macAddress maid:(NSString * _Nullable)maid maidType:(NSString * _Nullable)maidType networkType:(NSString * _Nullable)networkType phone:(NSString * _Nullable)phone region:(NSString * _Nullable)region revenues:(NSString * _Nullable)revenues signalStrength:(NSString * _Nullable)signalStrength streetName:(NSString * _Nullable)streetName streetNo:(NSString * _Nullable)streetNo streetType:(NSString * _Nullable)streetType timestampCollect:(NSString * _Nullable)timestampCollect town:(NSString * _Nullable)town unstructuredData:(NSString * _Nullable)unstructuredData wifiSSID:(NSString * _Nullable)wifiSSID OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The State object of the app
SWIFT_CLASS("_TtC10AppConsent7ACState")
@interface ACState : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end








/// The AppConsentDelegate protocol allows you to follow the notice lifecycle.
/// You can register as the notice delegate when initializing it through the <code>ACNotice</code> class.
/// \code
/// let appconsent = ACNotice(withAppKey: "YOUR_APP_KEY", forceApplyGDPR: true, forceATT: true)
/// appconsent.delegate = self
///
/// \endcode
SWIFT_PROTOCOL("_TtP10AppConsent18AppConsentDelegate_")
@protocol AppConsentDelegate
/// Called when the notice has been completed by the user or closed
- (void)appConsentDidFinish;
/// Called if anything went wrong in the notice lifecycle
/// \param error error describing the issue
///
- (void)appConsentDidFail:(NSError * _Nullable)error;
@optional
/// Called when a geolocation banner or notice has received an answer by the user.
- (void)appConsentGeolocationDidFinish;
/// Called when an error occur while trying to collect consent for geolocation purposes.
/// \param error error describing the issue
///
- (void)appConsentGeolocationDidFail:(NSError * _Nullable)error;
/// Optional, called when the notice introduction will be presented
- (void)appConsentWillAppear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction has been presented
- (void)appConsentDidAppear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction will close
- (void)appConsentWillDisappear SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Optional, called when the notice introduction has been closed
- (void)appConsentDidDisappear SWIFT_DEPRECATED_MSG("This is now obsolete.");
@end


/// Extension of the <code>AppConsentDelegate</code> protocol dedicated to the consents of purposes using the user’s geolocation.
SWIFT_PROTOCOL("_TtP10AppConsent36AppConsentGeolocationConsentDelegate_") SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate`` ")
@protocol AppConsentGeolocationConsentDelegate <AppConsentDelegate>
/// Called when a geolocation banner or notice has received an answer by the user.
- (void)appConsentGeolocationConsentReceived SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate.appConsentGeolocationDidFinish()`` ");
/// Called when an error occur while trying to collect consent for geolocation purposes.
/// \param error The reason of the error.
///
- (void)appConsentGeolocationConsentFailed:(NSError * _Nonnull)error SWIFT_DEPRECATED_MSG("This is now obsolete, prefer using ``AppConsentDelegate.appConsentGeolocationDidFail(_ error: Error)`` ");
@optional
/// Should the geolocation notice enlarge the geolocation icon?
///
/// returns:
/// <code>true</code> to display a bigger size image.
- (BOOL)displayBigGeolocationImage SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete.");
/// Should the buttons be in the scroll view of the geolocation notice.
/// important:
/// Only applies if the list of geoloc purposes is more than one.
///
/// returns:
/// <code>true</code> if the buttons should scroll, <code>false</code> otherwise.
- (BOOL)geolocationCtaScrolling SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("This is now obsolete.");
@end































#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
